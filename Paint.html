<!DOCTYPE html>
<html>

<head>
    <title>Áï´Â∏É</title>
    <style>
        body {
            user-select: none;
            -webkit-user-select: none;
            margin: 20;
        }

        ::-webkit-scrollbar {
            width: 15px;
            height: 15px;
            border-radius: 7px;
            color: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #949494;
            border-radius: 15px;
            background-clip: content-box;
            border: 5px solid transparent;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #aeaeae;
            background-clip: content-box;
            border: 5px solid transparent;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e00;
        }

        #opentool {
            position: fixed;
            width: 95%;
            height: 35px;
            font-size: 25px;
            bottom: 5px;
            right: 2.5%;
            text-align: center;
        }

        .tools {
            border-radius: 8px;
            background-color: #f0f0f0;
            position: fixed;
            width: 90%;
            bottom: 0;
            right: 2.5%;
            padding: 2.5%;
            margin-left: 2.5%;
            transition: all 0.2s ease-in-out;
        }

        .btn {
            background-color: #f0f0f0;
            font-size: 37px;
            border-radius: 100px;
            border: 0;
            cursor: pointer;
            width: 100px;
            min-width: 100px;
            height: 100px;
            margin-left: 5px;

            box-shadow:
                -10px -10px 15px rgba(255, 255, 255, 0.5),
                10px 10px 15px rgba(70, 70, 70, 0.12);
        }

        .btn:active {
            cursor: grabbing;
        }

        .row {
            display: flex;
            flex-direction: row;
        }

        .center {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .m-bottom-50 {
            margin-bottom: 50px;
        }

        .orf-auto {
            overflow: auto;
        }

        #colorPicker {
            width: 100px;
            min-width: 100px;
            height: 100px;
            margin-left: 5px;
        }

        .hashadow:hover {
            box-shadow:
                -10px -10px 15px rgba(255, 255, 255, 0.5),
                10px 10px 15px rgba(70, 70, 70, 0.12),
                inset -10px -10px 15px rgba(255, 255, 255, 0.5),
                inset 10px 10px 15px rgba(70, 70, 70, 0.06);
        }

        .hashadow:active {
            box-shadow:
                -10px -10px 15px rgba(255, 255, 255, 0.5),
                10px 10px 15px rgba(70, 70, 70, 0.12),
                inset -10px -10px 15px rgba(255, 255, 255, 0.5),
                inset 10px 10px 15px rgba(70, 70, 70, 0.15);
        }

        .draggable {
            cursor: grab;
        }

        .draggable:active {
            cursor: grabbing;
        }

        #lineWidth {
            position: fixed;
            width: 95%;
            left: 2.5%;
            background-color: #f0f0f0;
        }

        #lineDash {
            width: 100%;
        }

        #PaintCanvas {
            border: 1px solid #000;
            box-shadow: 5px 5px 10px #000;
            margin-top: 25px;
        }

        #GUICanvas {
            background-image: url(image/background/transbg_100x_144ppi.png);
            border: 1px solid #000;
            position: fixed;
            margin-top: 25px;
            left: 8px;
            z-index: -999;
        }
    </style>
</head>

<body>
    <input type="range" min="1" max="100" value="5" id="lineWidth">
    <div class="tools m-bottom-50">
        <label for="lineDash" style="font-weight: 800;">Â¢ûÂä†ËôõÁ∑öÈñìÈöî</label>
        <input type="range" min="1" max="100" value="0" id="lineDash">

        <div class="row orf-auto draggable">
            <button onclick="saveAsPNG()" class="btn center hashadow">PNG</button>
            <button onclick="saveAsJPGWhite()" class="btn center hashadow">JPG ÁôΩÂ∫ï</button>
            <button onclick="saveAsJPG()" class="btn center hashadow">JPG ÈªëÂ∫ï</button>
            <div id="undo-btn" class="btn center hashadow">‚Üª</div>
            <div id="redo-btn" class="btn center hashadow">‚Ü∫</div>
            <div id="brush" class="btn center hashadow">üñåÔ∏è</div>
            <div id="eraser" class="btn center hashadow">üßº</div>
            <div id="rectools" class="btn center hashadow">‚ñ¢</div>

            <input type="color" id="colorPicker">
        </div>
    </div>
    <canvas id="GUICanvas" width="1000" height="700"></canvas>
    <canvas id="PaintCanvas" width="1000" height="700"></canvas>
    <div id="opentool" class="hashadow">‚ñ≤</div>

    <script>
        // **
        // e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left === e.offsetX
        // ctx.lineJoin:
        // "round"ÔºöÈÄèÈÅéÂ°´Êªø‰∏ÄÂÄãÈ°çÂ§ñÁöÑÔºåÂúìÂøÉÂú®Áõ∏ÈÄ£ÈÉ®ÂàÜÊú´Á´ØÁöÑÊâáÂΩ¢ÔºåÁπ™Ë£ΩËßíËêΩÁöÑÂΩ¢ÁãÄ„ÄÇÂúìËßíÁöÑÂçäÂæëÊòØÁ∑öÊÆµÁöÑÂØ¨Â∫¶„ÄÇ
        // "bevel"ÔºöÂú®Áõ∏ÈÄ£ÈÉ®ÂàÜÁöÑÊú´Á´ØÂ°´Êªø‰∏ÄÂÄãÈ°çÂ§ñÁöÑ‰ª•‰∏âËßíÂΩ¢ÁÇ∫Â∫ïÁöÑÂçÄÂüüÔºåÊØèÂÄãÈÉ®ÂàÜÈÉΩÊúâÂêÑËá™Áç®Á´ãÁöÑÁü©ÂΩ¢ËßíËêΩ„ÄÇ
        // "miter"ÔºöÈÄèÈÅéÂª∂‰º∏Áõ∏ÈÄ£ÈÉ®ÂàÜÁöÑÂ§ñÁ∑£Ôºå‰ΩøÂÖ∂Áõ∏‰∫§Êñº‰∏ÄÈªûÔºåÂΩ¢Êàê‰∏ÄÂÄãÈ°çÂ§ñÁöÑËè±ÂΩ¢ÂçÄÂüü„ÄÇÈÄôÂÄãË®≠ÂÆöÂèØ‰ª•ÈÄèÈÅémiterLimitÂ±¨ÊÄßÁúãÂà∞ÊïàÊûú„ÄÇ
        // ctx.lineCap:
        // "butt"ÔºöÁ∑öÊÆµÁµÇÊ≠¢‰ª•ÊñπÂΩ¢ÁµêÊùü„ÄÇ
        // "round"ÔºöÁ∑öÊÆµÁµÇÊ≠¢‰ª•ÂúìÂΩ¢ÁµêÊùü„ÄÇ
        // "square"ÔºöÁ∑öÊÆµÁµÇÊ≠¢‰ª•ÊñπÂΩ¢ÁµêÊùüÔºå‰ΩÜÂ¢ûÂä†‰∫Ü‰∏ÄÂÄãÂØ¨Â∫¶ÂíåÁ∑öÊÆµÁõ∏ÂêåÔºåÈ´òÂ∫¶ÊòØÁ∑öÊÆµÂéöÂ∫¶ÁöÑ‰∏ÄÂçäÂçÄÂüü„ÄÇ
        const canvas = document.getElementById('PaintCanvas');
        const GUIcanvas = document.getElementById('GUICanvas');

        const context = canvas.getContext('2d');
        const GUIctx = GUIcanvas.getContext('2d');

        const tools = document.querySelector(".tools");
        const undoBtn = document.getElementById("undo-btn");
        const redoBtn = document.getElementById("redo-btn");
        const lineWidth = document.getElementById("lineWidth");
        const lineDash = document.getElementById("lineDash");
        const colorPicker = document.getElementById('colorPicker');
        const brush = document.getElementById("brush");
        const eraser = document.getElementById("eraser");
        const opentool = document.getElementById("opentool");
        const rectools = document.getElementById("rectools");
        const toolId = {
            brush: 0,
            eraser: 1,
            rect: 2
        };
        let selectools = toolId.brush;

        let undoStack = [context.getImageData(0, 0, canvas.width, canvas.height)];
        let redoStack = [];
        let isDrawing = false;
        let recordMX;
        let recordMY;
        let intervalId;
        let brushWidth = 12;
        let eraserWidth = 50;
        let rectWidth = 12;
        let rectX, rectY, rectwidth, rectheight;

        init();

        canvas.addEventListener('mousedown', e => {
            switch (selectools) {
                case 0:
                case 1:
                    isDrawing = true;
                    context.beginPath();
                    var mouseX = e.clientX - canvas.getBoundingClientRect().left;
                    var mouseY = e.clientY - canvas.getBoundingClientRect().top;
                    context.moveTo(mouseX, mouseY);
                    context.lineTo(mouseX, mouseY);
                    context.stroke();
                    if (e.shiftKey) {
                        context.lineTo(recordMX, recordMY);
                        context.stroke();
                    }
                    recordMX = mouseX;
                    recordMY = mouseY;
                    break;
                case 2:
                    isDrawing = true;
                    rectX = e.offsetX;
                    rectY = e.offsetY;
                    break;
                default:
                    break;
            }

        });

        canvas.addEventListener('mousemove', e => {
            switch (selectools) {
                case 0:
                case 1:
                    if (isDrawing) {
                        var mouseX = e.clientX - canvas.getBoundingClientRect().left;
                        var mouseY = e.clientY - canvas.getBoundingClientRect().top;
                        if (e.shiftKey) {
                            var dx = Math.abs(mouseX - recordMX);
                            var dy = Math.abs(mouseY - recordMY);
                            if (dx > dy) {
                                mouseY = recordMY;
                            }
                            else {
                                mouseX = recordMX;
                            }
                        }
                        context.lineTo(mouseX, mouseY);
                        context.stroke();
                    }
                    break;
                case 2:
                    if (isDrawing) {
                        rectwidth = e.offsetX - rectX;
                        rectheight = e.offsetY - rectY;
                        drawRect();
                        previewRect(e);
                    }
                    break;
                default:
                    break;
            }
        });

        canvas.addEventListener('mouseup', () => {
            switch (selectools) {
                case 2:
                    context.stroke();
                    GUIctx.clearRect(0, 0, GUIcanvas.width, GUIcanvas.height);
                    break;

                default:
                    break;
            }
            undoStack.push(context.getImageData(0, 0, canvas.width, canvas.height));
            redoStack = [];
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });
        canvas.addEventListener("touchstart", e => {
            switch (selectools) {
                case 0:
                case 1:
                    isDrawing = true;
                    context.beginPath();
                    var mouseX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
                    var mouseY = e.touches[0].clientY - canvas.getBoundingClientRect().top;
                    context.moveTo(mouseX, mouseY);
                    context.lineTo(mouseX, mouseY);
                    context.stroke();
                    break;
                case 2:
                    isDrawing = true;
                    rectX = e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left;
                    rectY = e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top;
                    break;
                default:
                    break;
            }
        });
        canvas.addEventListener("touchmove", e => {
            switch (selectools) {
                case 0:
                case 1:
                    if (isDrawing && e.touches.length < 2) {
                        e.preventDefault();
                        var mouseX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
                        var mouseY = e.touches[0].clientY - canvas.getBoundingClientRect().top;
                        context.lineTo(mouseX, mouseY);
                        context.stroke();
                    }
                    break;
                case 2:
                    if (isDrawing && e.touches.length < 2) {
                        e.preventDefault();
                        rectwidth = e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left - rectX;
                        rectheight = e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top - rectY;
                        drawRect();
                        previewRect_touch(e);
                    }
                    break;

                default:
                    break;
            }
        }, { passive: false });
        canvas.addEventListener("touchend", () => {
            switch (selectools) {
                case 2:
                    context.stroke();
                    GUIctx.clearRect(0, 0, GUIcanvas.width, GUIcanvas.height);
                    break;

                default:
                    break;
            }
            undoStack.push(context.getImageData(0, 0, canvas.width, canvas.height));
            redoStack = [];
            isDrawing = false;
        });
        canvas.addEventListener("touchcancel", () => {
            switch (selectools) {
                case 2:
                    context.stroke();
                    GUIctx.clearRect(0, 0, GUIcanvas.width, GUIcanvas.height);
                    break;

                default:
                    break;
            }
            undoStack.push(context.getImageData(0, 0, canvas.width, canvas.height));
            redoStack = [];
            isDrawing = false;
        });

        undoBtn.addEventListener('mousedown', () => {
            undo();
            if (event.button === 0) {
                intervalId = setInterval(undo, 200);
            }
        });
        undoBtn.addEventListener('touchstart', () => {
            intervalId = setInterval(undo, 200);
        });
        redoBtn.addEventListener('mousedown', () => {
            redo();
            if (event.button === 0) {
                intervalId = setInterval(redo, 200);
            }
        });
        redoBtn.addEventListener('touchstart', () => {
            intervalId = setInterval(redo, 200);
        });
        lineWidth.addEventListener('input', () => {
            context.lineWidth = lineWidth.value;
            GUIctx.lineWidth = context.lineWidth;
            switch (selectools) {
                case 0:
                    brushWidth = context.lineWidth;
                    break;
                case 1:
                    eraserWidth = context.lineWidth;
                    break;
                case 2:
                    rectWidth = context.lineWidth;
                    break;
                default:
                    break;
            }
        });

        lineDash.addEventListener('input', () => {
            context.setLineDash([context.lineWidth, lineDash.value]);
        });

        colorPicker.addEventListener('input', () => {
            context.strokeStyle = colorPicker.value;
        });

        brush.addEventListener('click', () => {
            selectools = toolId.brush;
            setools();
        });

        eraser.addEventListener('click', () => {
            selectools = toolId.eraser;
            setools();
        });

        rectools.addEventListener('click', () => {
            selectools = toolId.rect;
            setools();
        });

        opentool.addEventListener('click', () => {
            if (opentool.textContent === "‚ñº") {
                toolscloseprefix();
                setopentool();
            } else {
                tools.style.bottom = "0";
                opentool.textContent = "‚ñº";
            }
        });

        document.addEventListener('keydown', e => {
            if (e.ctrlKey && e.key === 'z') {
                undo();
            }
            else if (e.ctrlKey && e.shiftKey && e.key === 'Z') {
                redo();
            }
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                saveAsPNG();
            }
        });
        document.addEventListener('mouseup', () => {
            clearInterval(intervalId);
        });
        document.addEventListener('touchend', () => {
            clearInterval(intervalId);
        });
        function init() {
            canvas.width = window.innerWidth - 20;
            canvas.height = window.innerHeight - 80;
            context.lineJoin = 'round';
            context.lineCap = 'round';
            context.lineWidth = lineWidth.value;

            GUIcanvas.width = canvas.width;
            GUIcanvas.height = canvas.height;
            GUIctx.lineJoin = context.lineJoin;
            GUIctx.lineCap = context.lineWidth;
            GUIctx.lineWidth = context.lineWidth;

            toolscloseprefix();
            setools();
            setopentool();
        }
        function toolscloseprefix() {
            tools.style.bottom = -1 * (tools.offsetHeight + 100) + "px";
        }
        function setools() {
            switch (selectools) {
                case 0:
                    context.lineWidth = lineWidth.value = brushWidth;
                    context.globalCompositeOperation = 'source-over';
                    context.strokeStyle = colorPicker.value;
                    eraser.style = ""; rectools.style = "";
                    brush.style.boxShadow = "inset -10px -10px 15px rgba(255, 255, 255, 0.6),inset 10px 10px 15px rgba(70, 70, 70, 0.08)";
                    break;
                case 1:
                    context.lineWidth = lineWidth.value = eraserWidth;
                    context.globalCompositeOperation = 'destination-out';
                    context.strokeStyle = 'rgba(0, 0, 0, 1)';
                    brush.style = ""; rectools.style = "";
                    eraser.style.boxShadow = "inset -10px -10px 15px rgba(255, 255, 255, 0.6),inset 10px 10px 15px rgba(70, 70, 70, 0.08)";
                    break;
                case 2:
                    GUIctx.lineWidth = context.lineWidth = lineWidth.value = rectWidth;
                    context.globalCompositeOperation = 'source-over';
                    context.strokeStyle = colorPicker.value;
                    eraser.style = ""; brush.style = "";
                    rectools.style.boxShadow = "inset -10px -10px 15px rgba(255, 255, 255, 0.6),inset 10px 10px 15px rgba(70, 70, 70, 0.08)";
                    break;
                default:
                    break;
            }
        }
        function setopentool() {
            switch (selectools) {
                case 0:
                    opentool.textContent = "üñåÔ∏è";
                    break;
                case 1:
                    opentool.textContent = "üßº";
                    break;
                case 2:
                    opentool.textContent = "‚ñ¢";
                    break;

                default:
                    break;
            }
        }
        function drawRect() {
            context.beginPath();
            context.rect(rectX, rectY, rectwidth, rectheight);
        }
        function previewRect(e) {
            var mouseX = e.offsetX;
            var mouseY = e.offsetY;

            var width = mouseX - rectX;
            var height = mouseY - rectY;

            GUIctx.clearRect(0, 0, GUIcanvas.width, GUIcanvas.height);

            GUIctx.beginPath();
            GUIctx.rect(rectX, rectY, width, height);
            GUIctx.stroke();
        }
        function previewRect_touch(e) {
            var mouseX = e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left;
            var mouseY = e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top;

            var width = mouseX - rectX;
            var height = mouseY - rectY;

            GUIctx.clearRect(0, 0, GUIcanvas.width, GUIcanvas.height);

            GUIctx.beginPath();
            GUIctx.rect(rectX, rectY, width, height);
            GUIctx.stroke();
        }
        function undo() {
            if (undoStack.length > 1) {
                redoStack.push(undoStack.pop());
                context.putImageData(undoStack[undoStack.length - 1], 0, 0);
            }
        }
        function redo() {
            if (redoStack.length > 0) {
                undoStack.push(redoStack.pop());
                context.putImageData(undoStack[undoStack.length - 1], 0, 0);
            }
        }
        function saveAsPNG() {
            var link = document.createElement('a');
            link.download = 'canvas_image.png';
            link.href = canvas.toDataURL('image/png').replace("image/png", "image/octet-stream");
            link.click();
        }
        function saveAsJPG() {
            var link = document.createElement('a');
            link.download = 'canvas_image.jpg';
            link.href = canvas.toDataURL('image/jpeg', 0.8);
            link.click();
        }
        function saveAsJPGWhite() {
            var newCanvas = document.createElement('canvas');
            var newCtx = newCanvas.getContext('2d');

            newCanvas.width = canvas.width;
            newCanvas.height = canvas.height;

            newCtx.fillStyle = 'white';
            newCtx.fillRect(0, 0, newCanvas.width, newCanvas.height);

            newCtx.drawImage(canvas, 0, 0);

            var link = document.createElement('a');
            link.download = 'canvas_image.jpg';
            link.href = newCanvas.toDataURL('image/jpeg', 0.8);
            link.click();
        }

        /*let initialWidth = window.innerWidth;
        let initialHeight = window.innerHeight;
        function recordSize() {
            initialWidth = window.innerWidth;
            initialHeight = window.innerHeight;
        }
        window.addEventListener('resize', function (event) {
            recordSize();
            if (confirm("Ë™øÊï¥Â§ßÂ∞èÈÅ∫Â§±Áï∂ÂâçË≥áÊñôÔºåÁ¢∫Ë™çÊòØÂê¶Ë¶ÅË™øÊï¥?")) {
                canvas.width = window.innerWidth - 20;
                canvas.height = window.innerHeight - 50;
                context.lineJoin = 'round';
                context.lineCap = 'round';
                context.lineWidth = lineWidth.value;
                context.strokeStyle = colorPicker.value;
            } else {
                window.resizeTo(initialWidth, initialHeight);
            }
        });*/

        window.onbeforeunload = () => { return "ÊÇ®Á¢∫ÂÆöË¶ÅÈõ¢ÈñãÂóéÔºü"; }
    </script>
    <script>
        idrag(document.querySelector('.draggable'));
        function idrag(scrollContainer) {

            let isDragging = false;
            let startX, startY, scrollLeft, scrollTop;

            scrollContainer.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX - scrollContainer.getBoundingClientRect().left;
                startY = e.clientY - scrollContainer.getBoundingClientRect().top;
                scrollLeft = scrollContainer.scrollLeft;
                scrollTop = scrollContainer.scrollTop;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const deltaX = e.clientX - scrollContainer.getBoundingClientRect().left - startX;
                const deltaY = e.clientY - scrollContainer.getBoundingClientRect().top - startY;
                scrollContainer.scrollLeft = scrollLeft - deltaX;
                scrollContainer.scrollTop = scrollTop - deltaY;
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }
    </script>

</body>

<script src="js/paramname.js"></script>
<script src="js/fileutils.js"></script>
<script src="js/consoleprohibit.js"></script>
<script src="js/userprevent.js"></script>
<script src="js/limitlibs.js"></script>

</html>