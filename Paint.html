<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="https://lib.duckode.com/css/font-face.css">
    <link rel="stylesheet" href="https://lib.duckode.com/css/contextmenuutils.css">
    <title>Áï´Â∏É</title>
    <style>
        html {
            font-family: Poiret_One;
        }

        body {
            user-select: none;
            -webkit-user-select: none;
            margin: 20;
        }

        ::-webkit-scrollbar {
            width: 15px;
            height: 15px;
            border-radius: 7px;
            color: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #949494;
            border-radius: 15px;
            background-clip: content-box;
            border: 5px solid transparent;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #aeaeae;
            background-clip: content-box;
            border: 5px solid transparent;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e00;
        }

        #opentool {
            position: fixed;
            width: 95%;
            height: 35px;
            font-size: 25px;
            bottom: 5px;
            right: 2.5%;
            text-align: center;
        }

        .tools {
            border-radius: 8px;
            background-color: #f0f0f0;
            position: fixed;
            width: 90%;
            bottom: 0;
            right: 2.5%;
            padding: 2.5%;
            margin-left: 2.5%;
            transition: all 0.2s ease-in-out;
            z-index: 999;
        }

        .btn {
            background-color: #f0f0f0;
            font-size: 37px;
            border-radius: 100px;
            border: 0;
            cursor: pointer;
            width: 100px;
            min-width: 100px;
            height: 100px;
            margin-left: 5px;

            box-shadow:
                -10px -10px 15px rgba(255, 255, 255, 0.5),
                10px 10px 15px rgba(70, 70, 70, 0.12);
        }

        .btn:active {
            cursor: grabbing;
        }

        .row {
            display: flex;
            flex-direction: row;
        }

        .col {
            display: flex;
            flex-direction: column;
        }

        .center {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .m-bottom-50 {
            margin-bottom: 50px;
        }

        .orf-auto {
            overflow: auto;
        }

        #colorPicker {
            width: 100px;
            min-width: 100px;
            height: 100px;
            margin-left: 5px;
        }

        .hashadow:hover {
            box-shadow:
                -10px -10px 15px rgba(255, 255, 255, 0.5),
                10px 10px 15px rgba(70, 70, 70, 0.12),
                inset -10px -10px 15px rgba(255, 255, 255, 0.5),
                inset 10px 10px 15px rgba(70, 70, 70, 0.06);
        }

        .hashadow:active {
            box-shadow:
                -10px -10px 15px rgba(255, 255, 255, 0.5),
                10px 10px 15px rgba(70, 70, 70, 0.12),
                inset -10px -10px 15px rgba(255, 255, 255, 0.5),
                inset 10px 10px 15px rgba(70, 70, 70, 0.15);
        }

        .draggable {
            cursor: grab;
        }

        .draggable:active {
            cursor: grabbing;
        }

        #lineWidth {
            position: fixed;
            width: 95%;
            left: 2.5%;
            background-color: #f0f0f0;
        }

        #lineDash {
            width: 100%;
        }

        #rectround {
            width: 38px;
            height: 38px;
        }

        #Cap {
            width: 38px;
            height: 38px;
        }

        #penpressure {
            width: 38px;
            height: 38px;
        }

        #rectfill {
            width: 38px;
            height: 38px;
        }

        #rectfill-color {
            width: 38px;
            height: 38px;
        }

        #PaintCanvas {
            background-image: url(img/bg/transbg_100x_144ppi.png);
            border: 1px solid #000;
            position: absolute;
            box-shadow: 5px 5px 10px #000;
            margin-top: 25px;
        }

        #GUICanvas {
            border: 1px solid #000;
            position: absolute;
            margin-top: 25px;
            left: 8px;
        }
    </style>
</head>

<body>
    <input type="range" min="1" max="300" value="5" id="lineWidth">
    <div class="tools m-bottom-50 col">
        <div class="row">
            <label for="Cap" style="font-weight: 800;">Square End</label>
            <input type="checkbox" id="Cap">
            <label for="penpressure" style="font-weight: 800;">Pressure</label>
            <input type="checkbox" id="penpressure">
            <label for="rectfill" style="font-weight: 800;">Fill Color</label>
            <input type="checkbox" id="rectfill">
            <input type="color" id="rectfill-color" style="display: none;">
            <label for="rectround" style="font-weight: 800;">Rect Round</label>
            <input type="checkbox" id="rectround">
            <div class="col" id="rectround-switch" style="display: none;">
                <div class="row">
                    <input type="number" min="0" value="0" id="rrtl">
                    <input type="number" min="0" value="0" id="rrtr">
                </div>
                <div class="row">
                    <input type="number" min="0" value="0" id="rrbr">
                    <input type="number" min="0" value="0" id="rrbl">
                </div>
            </div>
        </div>

        <label for="lineDash" style="font-weight: 800;">Line Dash</label>
        <input type="range" min="1" max="100" value="0" id="lineDash">

        <div class="row orf-auto draggable">
            <button id="jpg-btn" class="btn center hashadow">File</button>
            <div id="undo-btn" class="btn center hashadow">‚Üª</div>
            <div id="redo-btn" class="btn center hashadow">‚Ü∫</div>
            <div id="brush" class="btn center hashadow">üñåÔ∏è</div>
            <div id="eraser" class="btn center hashadow">üßº</div>
            <div id="rectools" class="btn center hashadow">‚ñ¢</div>
            <div id="pipette" class="btn center hashadow"><img src="img/cursor/pipette_cursor_32x.png" alt=""></div>

            <input type="color" id="colorPicker">
        </div>
    </div>
    <canvas id="PaintCanvas" width="1000" height="700"></canvas>
    <canvas id="GUICanvas" width="1000" height="700"></canvas>
    <div id="opentool" class="hashadow">‚ñ≤</div>
    <script src="https://lib.duckode.com/js/storageutils.min.js"></script>
    <script src="https://lib.duckode.com/js/contextmenuutils.min.js"></script>
    <script>
        const jpg_btn = document.getElementById("jpg-btn");
        jpg_btn.addEventListener('click', e => {
            contextmenuutils.init(e, jpg_btn.parentElement.parentElement, (b, c) => {
                c.style.left = (e.pageX) - 0 + "px";
                c.style.top = (e.pageY) - 150 + "px";
                c.style.paddingTop = "10px";
                c.style.paddingBottom = "10px";
                c.style.zIndex = '999';
            })
            contextmenuutils.addItem("Export PNG", (c) => {
                defaultset(c, () => {
                    saveAsPNG();
                });
            });
            contextmenuutils.addItem("Export JPG", (c) => {
                JPGSettings(c, () => {
                    addJPGSettings();
                    removeItem("Export PNG");
                });
            });
            function addJPGSettings() {
                contextmenuutils.addItem("Back", (c) => {
                    c.addEventListener("click", () => {
                        removeAllItem();
                        contextmenuutils.addItem("Export PNG", (c) => {
                            defaultset(c, () => {
                                saveAsPNG();
                            });
                        });
                        contextmenuutils.addItem("Export JPG", (c) => {
                            JPGSettings(c, () => {
                                addJPGSettings();
                                removeItem("Export PNG");
                            });
                        });
                    });
                    c.addEventListener("mouseenter", () => {
                        c.style.background = "#202020";
                    });
                    c.addEventListener("mouseleave", () => {
                        c.style.background = "";
                    });
                });
                contextmenuutils.addItem("JPG Settings", (c) => {
                    c.style.fontSize = "25px";
                    c.style.cursor = "default";
                });
                const input = document.createElement('input');
                contextmenuutils.addItem("Quality", (c) => {
                    input.type = 'range';
                    input.step = 0.1;
                    input.min = 0;
                    input.max = 1;
                    input.value = storageutils.get('JPG_Quality', 0.8);
                    const span = document.createElement('span');
                    span.textContent = input.value * 10;
                    input.addEventListener('input', () => {
                        storageutils.set('JPG_Quality', input.value);
                        span.textContent = input.value * 10;
                    });
                    const btn = document.createElement('div');
                    btn.textContent = 'Default';
                    btn.addEventListener("click", () => {
                        localStorage.removeItem('JPG_Quality');
                        input.value = 0.8;
                        span.textContent = input.value * 10;
                    });
                    btn.addEventListener("mouseenter", () => {
                        btn.style.background = "#202020";
                    });
                    btn.addEventListener("mouseleave", () => {
                        btn.style.background = "";
                    });
                    c.appendChild(input);
                    c.appendChild(span);
                    c.appendChild(btn);
                });
                contextmenuutils.addItem("White Output", (c) => {
                    defaultset(c, () => {
                        saveAsJPGWhite(input.value);
                    });
                });
                contextmenuutils.addItem("Black Output", (c) => {
                    defaultset(c, () => {
                        saveAsJPGBlack(input.value);
                    });
                });
            }
            function defaultset(c, fn) {
                c.style.paddingLeft = "80px";
                c.style.paddingRight = "80px";
                c.addEventListener("click", () => {
                    fn();
                    contextmenuutils.remove();
                });
                c.addEventListener("mouseenter", () => {
                    c.style.background = "#202020";
                });
                c.addEventListener("mouseleave", () => {
                    c.style.background = "";
                });
            }

            function JPGSettings(c, fn) {
                c.style.paddingLeft = "80px";
                c.style.paddingRight = "80px";
                c.addEventListener("click", () => {
                    fn();
                    c.remove();
                });
                c.addEventListener("mouseenter", () => {
                    c.style.background = "#202020";
                });
                c.addEventListener("mouseleave", () => {
                    c.style.background = "";
                });
            }
            function removeItem(v) {
                var c = document.querySelectorAll("#ins-contextmenu div");
                c.forEach(element => {
                    if (element.textContent === v) {
                        element.remove();
                    }
                });
            }
            function removeAllItem() {
                var c = document.querySelectorAll("#ins-contextmenu div");
                c.forEach(element => {
                    element.remove();
                });
            }
        });
    </script>
    <script>
        // **
        // e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left === e.offsetX
        // ctx.lineJoin:
        // "round"ÔºöÈÄèÈÅéÂ°´Êªø‰∏ÄÂÄãÈ°çÂ§ñÁöÑÔºåÂúìÂøÉÂú®Áõ∏ÈÄ£ÈÉ®ÂàÜÊú´Á´ØÁöÑÊâáÂΩ¢ÔºåÁπ™Ë£ΩËßíËêΩÁöÑÂΩ¢ÁãÄ„ÄÇÂúìËßíÁöÑÂçäÂæëÊòØÁ∑öÊÆµÁöÑÂØ¨Â∫¶„ÄÇ
        // "bevel"ÔºöÂú®Áõ∏ÈÄ£ÈÉ®ÂàÜÁöÑÊú´Á´ØÂ°´Êªø‰∏ÄÂÄãÈ°çÂ§ñÁöÑ‰ª•‰∏âËßíÂΩ¢ÁÇ∫Â∫ïÁöÑÂçÄÂüüÔºåÊØèÂÄãÈÉ®ÂàÜÈÉΩÊúâÂêÑËá™Áç®Á´ãÁöÑÁü©ÂΩ¢ËßíËêΩ„ÄÇ
        // "miter"ÔºöÈÄèÈÅéÂª∂‰º∏Áõ∏ÈÄ£ÈÉ®ÂàÜÁöÑÂ§ñÁ∑£Ôºå‰ΩøÂÖ∂Áõ∏‰∫§Êñº‰∏ÄÈªûÔºåÂΩ¢Êàê‰∏ÄÂÄãÈ°çÂ§ñÁöÑËè±ÂΩ¢ÂçÄÂüü„ÄÇÈÄôÂÄãË®≠ÂÆöÂèØ‰ª•ÈÄèÈÅémiterLimitÂ±¨ÊÄßÁúãÂà∞ÊïàÊûú„ÄÇ
        // ctx.lineCap:
        // "butt"ÔºöÁ∑öÊÆµÁµÇÊ≠¢‰ª•ÊñπÂΩ¢ÁµêÊùü„ÄÇ
        // "round"ÔºöÁ∑öÊÆµÁµÇÊ≠¢‰ª•ÂúìÂΩ¢ÁµêÊùü„ÄÇ
        // "square"ÔºöÁ∑öÊÆµÁµÇÊ≠¢‰ª•ÊñπÂΩ¢ÁµêÊùüÔºå‰ΩÜÂ¢ûÂä†‰∫Ü‰∏ÄÂÄãÂØ¨Â∫¶ÂíåÁ∑öÊÆµÁõ∏ÂêåÔºåÈ´òÂ∫¶ÊòØÁ∑öÊÆµÂéöÂ∫¶ÁöÑ‰∏ÄÂçäÂçÄÂüü„ÄÇ
        const canvas = document.getElementById('PaintCanvas');
        const GUIcanvas = document.getElementById('GUICanvas');

        const context = canvas.getContext('2d');
        const GUIctx = GUIcanvas.getContext('2d');

        const tools = document.querySelector(".tools");
        const undoBtn = document.getElementById("undo-btn");
        const redoBtn = document.getElementById("redo-btn");
        const lineWidth = document.getElementById("lineWidth");
        const lineDash = document.getElementById("lineDash");
        const colorPicker = document.getElementById('colorPicker');
        const brush = document.getElementById("brush");
        const eraser = document.getElementById("eraser");
        const opentool = document.getElementById("opentool");
        const rectools = document.getElementById("rectools");
        const rectround = document.getElementById("rectround");
        const rectroundlabel = document.querySelector(`label[for="rectround"]`);
        const rrtl = document.getElementById("rrtl");
        const rrtr = document.getElementById("rrtr");
        const rrbl = document.getElementById("rrbl");
        const rrbr = document.getElementById("rrbr");
        const rectround_switch = document.getElementById("rectround-switch");
        const Cap = document.getElementById("Cap");
        const rectfill = document.getElementById("rectfill");
        const rectfilllabel = document.querySelector(`label[for="rectfill"]`);
        const rectfill_color = document.getElementById("rectfill-color");
        const pipette = document.getElementById("pipette");
        const penpressure = document.getElementById("penpressure");
        const toolId = {
            brush: 0,
            eraser: 1,
            rect: 2,
            colorPipette: 3
        };
        let selectools = toolId.brush;

        let undoStack = [];
        let redoStack = [];
        let isDrawing = false;
        let recordMX;
        let recordMY;
        let intervalId;
        let brushWidth = 5;
        let eraserWidth = 50;
        let isdrawrect = false;
        let rectWidth = 5;
        let rectX, rectY, rectwidth, rectheight;
        let leaveGUIcanvas = false;
        let isPipette = false;
        let isAlt = false;
        let isM0 = false;
        let retool = null;
        let epos;
        let lastX, lastY, lastTime, speed = 0;

        init();

        GUIcanvas.addEventListener('mousedown', e => {
            switch (selectools) {
                case 0:
                case 1:
                    if (!isAlt) {
                        isDrawing = true;
                        context.beginPath();
                        var mouseX = e.clientX - canvas.getBoundingClientRect().left;
                        var mouseY = e.clientY - canvas.getBoundingClientRect().top;
                        context.moveTo(mouseX, mouseY);
                        context.lineTo(mouseX, mouseY);
                        context.stroke();
                        if (e.shiftKey) {
                            context.lineTo(recordMX, recordMY);
                            context.stroke();
                        }
                        recordMX = mouseX;
                        recordMY = mouseY;
                    }
                    break;
                case 2:
                    isDrawing = true;
                    rectX = e.offsetX;
                    rectY = e.offsetY;
                    break;
                default:
                    break;
            }
        });
        document.addEventListener('mousemove', e => {
            switch (selectools) {
                case 0:
                case 1:
                    if (isDrawing) {
                        var mouseX = e.clientX - canvas.getBoundingClientRect().left;
                        var mouseY = e.clientY - canvas.getBoundingClientRect().top;
                        if (e.shiftKey) {
                            var dx = Math.abs(mouseX - recordMX);
                            var dy = Math.abs(mouseY - recordMY);
                            if (dx > dy) {
                                mouseY = recordMY;
                            }
                            else {
                                mouseX = recordMX;
                            }
                        }
                        context.lineTo(mouseX, mouseY);
                        context.stroke();

                        if (penpressure.checked) {
                            let calculateSpeed = getBrushSpeed();
                            context.lineWidth = calculateSpeed(mouseX, mouseY);

                            context.beginPath();
                            context.moveTo(mouseX, mouseY);
                            context.lineTo(mouseX, mouseY);
                            context.stroke();

                            function getBrushSpeed() {
                                return function (x, y) {
                                    let currentTime = Date.now();
                                    if (lastX !== undefined && lastY !== undefined && lastTime !== undefined) {
                                        let distance = Math.sqrt((x - lastX) ** 2 + (y - lastY) ** 2);
                                        let timeDiff = currentTime - lastTime;
                                        let newSpeed = timeDiff / distance;

                                        let smoothingFactor = 0.1;
                                        speed += (newSpeed - speed) * smoothingFactor;
                                    }
                                    lastX = x;
                                    lastY = y;
                                    lastTime = currentTime;
                                    speed = Math.max(Math.max(0, parseInt(lineWidth.value)), Math.min(speed, Math.min(parseInt(lineWidth.value * 2), 20)));

                                    return speed;
                                };
                            }
                        }
                    }
                    if (!leaveGUIcanvas) {
                        setPointer(e);
                    }
                    break;
                case 2:
                    if (isDrawing) {
                        rectwidth = e.offsetX - rectX;
                        rectheight = e.offsetY - rectY;
                        drawRect();
                        previewRect(e);
                    }
                    break;
                default:
                    break;
            }
        });
        GUIcanvas.addEventListener('mouseup', e => {
            switch (selectools) {
                case 2:
                    if (isdrawrect && rectfill.checked) {
                        context.fillStyle = rectfill_color.value;
                        context.fill();
                    }
                    isdrawrect = false;
                    context.stroke();
                    clear(GUIctx, GUIcanvas);
                    break;

                default:
                    break;
            }
            undoStack.push(context.getImageData(0, 0, canvas.width, canvas.height));
            redoStack = [];
            isDrawing = false;
        });
        GUIcanvas.addEventListener('mouseleave', () => {
            leaveGUIcanvas = true;
            clear(GUIctx, GUIcanvas);
        });
        GUIcanvas.addEventListener('mouseenter', () => {
            leaveGUIcanvas = false;
        });
        document.addEventListener('mouseup', () => {
            isDrawing = false;
        });
        GUIcanvas.addEventListener("touchstart", e => {
            switch (selectools) {
                case 0:
                case 1:
                    isDrawing = true;
                    context.beginPath();
                    var mouseX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
                    var mouseY = e.touches[0].clientY - canvas.getBoundingClientRect().top;
                    context.moveTo(mouseX, mouseY);
                    context.lineTo(mouseX, mouseY);
                    context.stroke();
                    if (penpressure.checked) {
                        context.lineWidth = 1;
                    }
                    break;
                case 2:
                    isDrawing = true;
                    rectX = e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left;
                    rectY = e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top;
                    break;
                default:
                    break;
            }
        });
        GUIcanvas.addEventListener("touchmove", e => {
            switch (selectools) {
                case 0:
                case 1:
                    if (isDrawing && e.touches.length < 2) {
                        e.preventDefault();
                        var mouseX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
                        var mouseY = e.touches[0].clientY - canvas.getBoundingClientRect().top;
                        context.lineTo(mouseX, mouseY);
                        context.stroke();
                        if (penpressure.checked) {
                            context.lineWidth += (e.touches[0].force * lineWidth.value - context.lineWidth) * 0.1;

                            context.beginPath();
                            context.moveTo(mouseX, mouseY);
                            context.lineTo(mouseX, mouseY);
                            context.stroke();
                        }
                    }
                    setPointer_touch(e);
                    break;
                case 2:
                    if (isDrawing && e.touches.length < 2) {
                        e.preventDefault();
                        rectwidth = e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left - rectX;
                        rectheight = e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top - rectY;
                        drawRect();
                        previewRect_touch(e);
                    }
                    break;

                default:
                    break;
            }
        }, { passive: false });
        GUIcanvas.addEventListener("touchend", e => {
            switch (selectools) {
                case 2:
                    if (rectfill.checked) {
                        context.fillStyle = rectfill_color.value;
                        context.fill();
                    }
                    context.stroke();
                    clear(GUIctx, GUIcanvas);
                    break;

                default:
                    break;
            }
            undoStack.push(context.getImageData(0, 0, canvas.width, canvas.height));
            redoStack = [];
            isDrawing = false;
        });
        GUIcanvas.addEventListener("touchcancel", () => {
            switch (selectools) {
                case 2:
                    if (rectfill.checked) {
                        context.fillStyle = rectfill_color.value;
                        context.fill();
                    }
                    context.stroke();
                    clear(GUIctx, GUIcanvas);
                    break;

                default:
                    break;
            }
            undoStack.push(context.getImageData(0, 0, canvas.width, canvas.height));
            redoStack = [];
            isDrawing = false;
        });

        undoBtn.addEventListener('mousedown', () => {
            undo();
            if (event.button === 0) {
                intervalId = setInterval(undo, 200);
            }
        });
        undoBtn.addEventListener('touchstart', () => {
            intervalId = setInterval(undo, 200);
        });
        redoBtn.addEventListener('mousedown', () => {
            redo();
            if (event.button === 0) {
                intervalId = setInterval(redo, 200);
            }
        });
        redoBtn.addEventListener('touchstart', () => {
            intervalId = setInterval(redo, 200);
        });
        lineWidth.addEventListener('input', () => {
            context.lineWidth = lineWidth.value;
            switch (selectools) {
                case 0:
                    brushWidth = context.lineWidth;
                    break;
                case 1:
                    eraserWidth = context.lineWidth;
                    break;
                case 2:
                    rectWidth = context.lineWidth;
                    GUIctx.lineWidth = context.lineWidth;
                    break;
                default:
                    break;
            }
        });

        rectfill.addEventListener('change', () => {
            if (rectfill.checked) {
                rectfill_color.style.display = "";
            } else {
                rectfill_color.style.display = "none";
            }
        });

        Cap.addEventListener('change', () => {
            if (!Cap.checked) {
                context.lineJoin = 'round';
                context.lineCap = 'round';
                GUIctx.lineJoin = 'round';
                GUIctx.lineCap = 'round';
            } else {
                context.lineJoin = 'miter';
                context.lineCap = 'butt';
                GUIctx.lineJoin = 'miter';
                GUIctx.lineCap = 'butt';
            }
        });

        rectround.addEventListener('change', () => {
            if (rectround.checked) {
                rectround_switch.style.display = "";
            } else {
                rectround_switch.style.display = "none";
            }
        });

        lineDash.addEventListener('input', () => {
            context.setLineDash([context.lineWidth, lineDash.value]);
            GUIctx.setLineDash([GUIctx.lineWidth, lineDash.value]);
        });

        colorPicker.addEventListener('input', () => {
            ColorPickerChange();
        });

        brush.addEventListener('click', () => {
            selectools = toolId.brush;
            setools();
            setCursor();
        });

        eraser.addEventListener('click', () => {
            selectools = toolId.eraser;
            setools();
            setCursor();
        });

        rectools.addEventListener('click', () => {
            selectools = toolId.rect;
            setools();
            setCursor();
        });
        pipette.addEventListener('click', () => {
            selectools = toolId.colorPipette;
            setools();
            setCursor();
        });
        penpressure.addEventListener('change', () => {
            if (!penpressure.checked) {
                context.lineWidth = lineWidth.value;
            }
        });

        opentool.addEventListener('click', () => {
            if (opentool.textContent === "‚ñº") {
                toolscloseprefix();
                setopentool();
            } else {
                tools.style.bottom = "0";
                opentool.textContent = "‚ñº";
            }
        });

        document.addEventListener('keydown', e => {
            if (e.ctrlKey && e.key === 'z') {
                undo();
            }
            else if (e.ctrlKey && e.shiftKey && e.key === 'Z') {
                redo();
            }
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                saveAsPNG();
            }
            if (e.altKey) {
                e.preventDefault();
                isAlt = true;
                if (retool === null) {
                    retool = selectools;
                    clear(GUIctx, GUIcanvas);
                    selectools = toolId.colorPipette;
                    setCursor();
                }
            }
        });
        document.addEventListener("keyup", e => {
            if (!e.altKey) {
                isAlt = false;
                if (retool !== null && !isM0) {
                    selectools = retool;
                    setools();
                    setCursor();
                    if (!leaveGUIcanvas && selectools !== toolId.colorPipette) {
                        setPointer(epos);
                    }
                    retool = null;
                }
            }
        });
        GUIcanvas.addEventListener('mousedown', e => {
            if (isAlt && e.button === 0) {
                isPipette = true;
                setColorPipette(e.clientX, e.clientY);
                setPointer(epos);
            }
            if (e.button === 0) {
                isM0 = true;
            }
            if (selectools === toolId.colorPipette) {
                isPipette = true;
                setColorPipette(e.clientX, e.clientY);
                setPointer(epos);
            }
        });
        GUIcanvas.addEventListener('mousemove', e => {
            if (isPipette) {
                setColorPipette(e.clientX, e.clientY);
                if (!leaveGUIcanvas) {
                    setPointer(epos);
                }
            } else if (isAlt && !isM0) {
                clear(GUIctx, GUIcanvas);
            }
        });
        GUIcanvas.addEventListener('touchstart', e => {
            epos = e;
            if (selectools === toolId.colorPipette && e.touches.length < 2) {
                isPipette = true;
                if (retool === null) {
                    retool = selectools;
                    selectools = toolId.colorPipette;
                }
                setColorPipette(e.touches[0].clientX, e.touches[0].clientY);
                setPointer_touch(epos);
            }
            if (e.touches.length > 2) {
                e.preventDefault();
                isPipette = true;
                if (retool === null) {
                    retool = selectools;
                    selectools = toolId.colorPipette;
                }
                setColorPipette(e.touches[0].clientX, e.touches[0].clientY);
                setPointer_touch(epos);
            }
        });
        GUIcanvas.addEventListener('touchmove', e => {
            epos = e;
            if (isPipette) {
                e.preventDefault();
                setColorPipette(e.touches[0].clientX, e.touches[0].clientY);
                setPointer_touch(epos);
            }
        }, { passive: false });
        GUIcanvas.addEventListener('touchend', e => {
            if (selectools === toolId.colorPipette && e.touches.length === 0) {
                isPipette = false;
                clear(GUIctx, GUIcanvas);
                if (retool !== null) {
                    selectools = retool;
                    retool = null;
                }
            }
        });
        GUIcanvas.addEventListener('touchcancel', e => {
            if (selectools === toolId.colorPipette && e.touches.length === 0) {
                isPipette = false;
                clear(GUIctx, GUIcanvas);
                if (retool !== null) {
                    selectools = retool;
                    retool = null;
                }
            }
        });
        document.addEventListener('mousedown', e => {
            clearInterval(intervalId);
        });
        document.addEventListener('mousemove', e => {
            epos = e;
        });
        document.addEventListener('mouseup', e => {
            if (e.button === 0) {
                isM0 = false;
                isPipette = false;
                if (selectools === toolId.colorPipette) {
                    clear(GUIctx, GUIcanvas);
                }
            }
            if (!isAlt && e.button === 0) {
                if (retool !== null) {
                    selectools = retool;
                    setools();
                    setCursor();
                    clear(GUIctx, GUIcanvas);
                    if (!leaveGUIcanvas) {
                        setPointer(epos);
                    }
                    retool = null;
                }
            } else if (isAlt && e.button === 0) {
                clear(GUIctx, GUIcanvas);
                if (!leaveGUIcanvas) {
                    setPointer(epos);
                }
            }
        });
        document.addEventListener('touchend', () => {
            clearInterval(intervalId);
        });
        function init() {
            canvas.width = window.innerWidth - 20;
            canvas.height = window.innerHeight - 80;
            undoStack = [context.getImageData(0, 0, canvas.width, canvas.height)];
            context.lineJoin = 'round';
            context.lineCap = 'round';
            context.lineWidth = lineWidth.value;

            GUIcanvas.width = canvas.width;
            GUIcanvas.height = canvas.height;
            GUIctx.lineJoin = 'round';
            GUIctx.lineCap = 'round';
            GUIctx.lineWidth = context.lineWidth;

            toolscloseprefix();
            setools();
            setCursor();
            setopentool();
        }
        function toolscloseprefix() {
            tools.style.bottom = -1 * (tools.offsetHeight + 100) + "px";
        }
        function setools() {
            switch (selectools) {
                case 0:
                    rectround.style.display = "none"; rectfill.style.display = "none"; rectroundlabel.style.display = "none"; rectfilllabel.style.display = "none";
                    GUIctx.lineWidth = 1;
                    context.lineWidth = lineWidth.value = brushWidth;
                    context.globalCompositeOperation = 'source-over';
                    context.strokeStyle = colorPicker.value;
                    eraser.style = ""; rectools.style = ""; pipette.style = "";
                    brush.style.boxShadow = "inset -10px -10px 15px rgba(255, 255, 255, 0.6),inset 10px 10px 15px rgba(70, 70, 70, 0.08)";
                    break;
                case 1:
                    rectround.style.display = "none"; rectfill.style.display = "none"; rectroundlabel.style.display = "none"; rectfilllabel.style.display = "none";
                    GUIctx.lineWidth = 1;
                    context.lineWidth = lineWidth.value = eraserWidth;
                    context.globalCompositeOperation = 'destination-out';
                    context.strokeStyle = 'rgba(0, 0, 0, 1)';
                    brush.style = ""; rectools.style = ""; pipette.style = "";
                    eraser.style.boxShadow = "inset -10px -10px 15px rgba(255, 255, 255, 0.6),inset 10px 10px 15px rgba(70, 70, 70, 0.08)";
                    break;
                case 2:
                    rectround.style.display = ""; rectfill.style.display = ""; rectroundlabel.style.display = ""; rectfilllabel.style.display = "";
                    GUIctx.strokeStyle = context.strokeStyle;
                    GUIctx.lineWidth = context.lineWidth = lineWidth.value = rectWidth;
                    context.globalCompositeOperation = 'source-over';
                    context.strokeStyle = colorPicker.value;
                    eraser.style = ""; brush.style = ""; pipette.style = "";
                    rectools.style.boxShadow = "inset -10px -10px 15px rgba(255, 255, 255, 0.6),inset 10px 10px 15px rgba(70, 70, 70, 0.08)";
                    break;
                case 3:
                    rectround.style.display = "none"; rectfill.style.display = "none"; rectroundlabel.style.display = "none"; rectfilllabel.style.display = "none";
                    eraser.style = ""; brush.style = ""; rectools.style = "";
                    pipette.style.boxShadow = "inset -10px -10px 15px rgba(255, 255, 255, 0.6),inset 10px 10px 15px rgba(70, 70, 70, 0.08)";
                    break;
                default:
                    break;
            }
        }
        function setopentool() {
            switch (selectools) {
                case 0:
                    opentool.textContent = "üñåÔ∏è";
                    break;
                case 1:
                    opentool.textContent = "üßº";
                    break;
                case 2:
                    opentool.textContent = "‚ñ¢";
                    break;
                case 3:
                    opentool.textContent = "ChooseüñåÔ∏è";
                    break;

                default:
                    break;
            }
        }
        function setCursor() {
            switch (selectools) {
                case 0:
                case 1:
                    GUIcanvas.style.cursor = 'none';
                    break;
                case 2:
                    GUIcanvas.style.cursor = 'crosshair';
                    break;
                case 3:
                    GUIcanvas.style.cursor = 'url("img/cursor/pipette_cursor_32x.png") 12 34, auto';
                    break;
                default:
                    break;
            }
        }
        function setPointer(e) {
            switch (selectools) {
                case 0:
                case 1:
                    GUIctx.beginPath();
                    clear(GUIctx, GUIcanvas);
                    GUIctx.arc(e.clientX - GUIcanvas.getBoundingClientRect().left, e.clientY - GUIcanvas.getBoundingClientRect().top, Math.max(context.lineWidth / 2 - 1, 0), 0, 2 * Math.PI);
                    GUIctx.strokeStyle = brightness_RGB(...getPixelColor(e.clientX - GUIcanvas.getBoundingClientRect().left, e.clientY - GUIcanvas.getBoundingClientRect().top)) > 0.5 ? '#fff' : getPixelAlphaColor(e.clientX - GUIcanvas.getBoundingClientRect().left, e.clientY - GUIcanvas.getBoundingClientRect().top) > 0 ? '#000' : '#fff';
                    GUIctx.stroke();

                    GUIctx.beginPath();
                    GUIctx.arc(e.clientX - GUIcanvas.getBoundingClientRect().left, e.clientY - GUIcanvas.getBoundingClientRect().top, Math.max(context.lineWidth / 2 - 0.5, 0), 0, 2 * Math.PI);
                    GUIctx.lineWidth = 1.3;
                    GUIctx.strokeStyle = brightness_RGB(...getPixelColor(e.clientX - GUIcanvas.getBoundingClientRect().left, e.clientY - GUIcanvas.getBoundingClientRect().top)) > 0.5 ? '#000' : getPixelAlphaColor(e.clientX - GUIcanvas.getBoundingClientRect().left, e.clientY - GUIcanvas.getBoundingClientRect().top) > 0 ? '#fff' : '#000';
                    GUIctx.stroke();
                    break;
                case 2:
                    break;
                case 3:
                    let reLineJoin = GUIctx.lineJoin;
                    let reLineCap = GUIctx.lineJoin;
                    GUIctx.lineJoin = 'miter';
                    GUIctx.lineCap = 'butt';

                    clear(GUIctx, GUIcanvas);
                    GUIctx.beginPath();
                    GUIctx.lineWidth = 15;
                    GUIctx.arc(e.clientX - GUIcanvas.getBoundingClientRect().left, e.clientY - GUIcanvas.getBoundingClientRect().top, 50, 0.49 * Math.PI, 0.91 * Math.PI);
                    GUIctx.strokeStyle = brightness(colorPicker.value) > 0.5 ? '#000' : '#fff';
                    GUIctx.stroke();
                    GUIctx.beginPath();
                    GUIctx.lineWidth = 12;
                    GUIctx.arc(e.clientX - GUIcanvas.getBoundingClientRect().left, e.clientY - GUIcanvas.getBoundingClientRect().top, 50, 0.5 * Math.PI, 0.9 * Math.PI);
                    GUIctx.strokeStyle = colorPicker.value;
                    GUIctx.stroke();

                    GUIctx.lineJoin = reLineJoin;
                    GUIctx.lineCap = reLineCap;
                    break;
                default:
                    break;
            }
        }
        function setPointer_touch(e) {
            switch (selectools) {
                case 0:
                case 1:
                    GUIctx.beginPath();
                    clear(GUIctx, GUIcanvas);
                    GUIctx.arc(e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left, e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top, Math.max(context.lineWidth / 2 - 1, 0), 0, 2 * Math.PI);
                    GUIctx.strokeStyle = brightness_RGB(...getPixelColor(e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left, e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top)) > 0.5 ? '#fff' : getPixelAlphaColor(e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left, e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top) > 0 ? '#000' : '#fff';
                    GUIctx.stroke();

                    GUIctx.beginPath();
                    GUIctx.arc(e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left, e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top, Math.max(context.lineWidth / 2 - 0.5, 0), 0, 2 * Math.PI);
                    GUIctx.lineWidth = 1.3;
                    GUIctx.strokeStyle = brightness_RGB(...getPixelColor(e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left, e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top)) > 0.5 ? '#000' : getPixelAlphaColor(e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left, e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top) > 0 ? '#fff' : '#000';
                    GUIctx.stroke();
                    break;
                case 2:
                    break;
                case 3:
                    let reLineJoin = GUIctx.lineJoin;
                    let reLineCap = GUIctx.lineJoin;
                    GUIctx.lineJoin = 'miter';
                    GUIctx.lineCap = 'butt';

                    clear(GUIctx, GUIcanvas);
                    GUIctx.beginPath();
                    GUIctx.lineWidth = 15;
                    GUIctx.arc(e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left, e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top, 150, 0.49 * Math.PI, 0.91 * Math.PI);
                    GUIctx.strokeStyle = brightness(colorPicker.value) > 0.5 ? '#000' : '#fff';
                    GUIctx.stroke();
                    GUIctx.beginPath();
                    GUIctx.lineWidth = 12;
                    GUIctx.arc(e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left, e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top, 150, 0.5 * Math.PI, 0.9 * Math.PI);
                    GUIctx.strokeStyle = colorPicker.value;
                    GUIctx.stroke();

                    GUIctx.lineJoin = reLineJoin;
                    GUIctx.lineCap = reLineCap;
                    break;
                default:
                    break;
            }
        }
        function drawRect() {
            context.beginPath();
            if (!rectround.checked) {
                context.rect(rectX, rectY, rectwidth, rectheight);
            } else {
                context.roundRect(rectX, rectY, rectwidth, rectheight, [rrtl.value, rrtr.value, rrbl.value, rrbr.value]);
            }
            isdrawrect = true;
        }
        function previewRect(e) {
            var mouseX = e.offsetX;
            var mouseY = e.offsetY;

            var width = mouseX - rectX;
            var height = mouseY - rectY;

            clear(GUIctx, GUIcanvas);

            GUIctx.beginPath();
            if (!rectround.checked) {
                GUIctx.rect(rectX, rectY, width, height);

                if (rectfill.checked) {
                    GUIctx.fillStyle = rectfill_color.value;
                    GUIctx.fill();
                }
            } else {
                GUIctx.roundRect(rectX, rectY, width, height, [rrtl.value, rrtr.value, rrbl.value, rrbr.value]);

                if (rectfill.checked) {
                    GUIctx.fillStyle = rectfill_color.value;
                    GUIctx.fill();
                }
            }
            GUIctx.stroke();
        }
        function previewRect_touch(e) {
            var mouseX = e.touches[0].clientX - GUIcanvas.getBoundingClientRect().left;
            var mouseY = e.touches[0].clientY - GUIcanvas.getBoundingClientRect().top;

            var width = mouseX - rectX;
            var height = mouseY - rectY;

            clear(GUIctx, GUIcanvas);

            GUIctx.beginPath();
            if (!rectround.checked) {
                GUIctx.rect(rectX, rectY, width, height);

                if (rectfill.checked) {
                    GUIctx.fillStyle = rectfill_color.value;
                    GUIctx.fill();
                }
            } else {
                GUIctx.roundRect(rectX, rectY, width, height, [rrtl.value, rrtr.value, rrbl.value, rrbr.value]);

                if (rectfill.checked) {
                    GUIctx.fillStyle = rectfill_color.value;
                    GUIctx.fill();
                }
            }
            GUIctx.stroke();
        }
        function getPixelColor(x, y) {
            const context = canvas.getContext('2d');
            const pixelData = context.getImageData(x, y, 1, 1, { willReadFrequently: true }).data;
            const color = [pixelData[0], pixelData[1], pixelData[2]];
            return color;
        }
        function getPixelAlphaColor(x, y) {
            const context = canvas.getContext('2d');
            const pixelData = context.getImageData(x, y, 1, 1, { willReadFrequently: true }).data;
            const alpha = pixelData[3];
            return alpha;
        }
        function rgbToHex(r, g, b) {
            const red = Math.max(0, Math.min(255, r));
            const green = Math.max(0, Math.min(255, g));
            const blue = Math.max(0, Math.min(255, b));

            const hexRed = red.toString(16).padStart(2, '0');
            const hexGreen = green.toString(16).padStart(2, '0');
            const hexBlue = blue.toString(16).padStart(2, '0');

            return `#${hexRed}${hexGreen}${hexBlue}`;
        }
        function HexReverse(hexColor) {
            hexColor = hexColor.replace('#', '');

            var r = parseInt(hexColor.substring(0, 2), 16);
            var g = parseInt(hexColor.substring(2, 4), 16);
            var b = parseInt(hexColor.substring(4, 6), 16);

            var wr = 255 - r;
            var wg = 255 - g;
            var wb = 255 - b;

            var result = "#" + ('00' + wr.toString(16)).slice(-2) + ('00' + wg.toString(16)).slice(-2) + ('00' + wb.toString(16)).slice(-2);

            return result;
        }
        function clear(ctx, cvs) {
            ctx.clearRect(0, 0, cvs.width, cvs.height);
        }
        function ColorPickerChange() {
            context.strokeStyle = colorPicker.value;
            GUIctx.strokeStyle = context.strokeStyle;
        }
        function setColorPipette(x, y) {
            colorPicker.value = rgbToHex(...getPixelColor(x - canvas.getBoundingClientRect().left, y - canvas.getBoundingClientRect().top));
            ColorPickerChange();
        }
        function brightness(hexColor) {
            hexColor = hexColor.replace('#', '');
            var r = parseInt(hexColor.substring(0, 2), 16);
            var g = parseInt(hexColor.substring(2, 4), 16);
            var b = parseInt(hexColor.substring(4, 6), 16);

            var brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return brightness;
        }
        function brightness_RGB(r, g, b) {
            return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        }
        function undo() {
            if (undoStack.length > 1) {
                redoStack.push(undoStack.pop());
                context.putImageData(undoStack[undoStack.length - 1], 0, 0);
            }
        }
        function redo() {
            if (redoStack.length > 0) {
                undoStack.push(redoStack.pop());
                context.putImageData(undoStack[undoStack.length - 1], 0, 0);
            }
        }
        function saveAsPNG() {
            var link = document.createElement('a');
            link.download = 'canvas_image.png';
            link.href = canvas.toDataURL('image/png').replace("image/png", "image/octet-stream");
            link.click();
        }
        function saveAsJPGBlack(v) {
            var link = document.createElement('a');
            link.download = `canvas_image_black_${v * 10}.jpg`;
            link.href = canvas.toDataURL('image/jpeg', v);
            link.click();
        }
        function saveAsJPGWhite(v) {
            var newCanvas = document.createElement('canvas');
            var newCtx = newCanvas.getContext('2d');

            newCanvas.width = canvas.width;
            newCanvas.height = canvas.height;

            newCtx.fillStyle = 'white';
            newCtx.fillRect(0, 0, newCanvas.width, newCanvas.height);

            newCtx.drawImage(canvas, 0, 0);

            var link = document.createElement('a');
            link.download = `canvas_image_white_${v * 10}.jpg`;
            link.href = newCanvas.toDataURL('image/jpeg', v);
            link.click();
        }

        /*let initialWidth = window.innerWidth;
        let initialHeight = window.innerHeight;
        function recordSize() {
            initialWidth = window.innerWidth;
            initialHeight = window.innerHeight;
        }
        window.addEventListener('resize', function (event) {
            recordSize();
            if (confirm("Ë™øÊï¥Â§ßÂ∞èÈÅ∫Â§±Áï∂ÂâçË≥áÊñôÔºåÁ¢∫Ë™çÊòØÂê¶Ë¶ÅË™øÊï¥?")) {
                canvas.width = window.innerWidth - 20;
                canvas.height = window.innerHeight - 50;
                context.lineJoin = 'round';
                context.lineCap = 'round';
                context.lineWidth = lineWidth.value;
                context.strokeStyle = colorPicker.value;
            } else {
                window.resizeTo(initialWidth, initialHeight);
            }
        });*/

        window.onbeforeunload = () => { return "ÊÇ®Á¢∫ÂÆöË¶ÅÈõ¢ÈñãÂóéÔºü"; }
    </script>
    <script>
        idrag(document.querySelector('.draggable'));
        function idrag(scrollContainer) {

            let isDragging = false;
            let startX, startY, scrollLeft, scrollTop;

            scrollContainer.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX - scrollContainer.getBoundingClientRect().left;
                startY = e.clientY - scrollContainer.getBoundingClientRect().top;
                scrollLeft = scrollContainer.scrollLeft;
                scrollTop = scrollContainer.scrollTop;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const deltaX = e.clientX - scrollContainer.getBoundingClientRect().left - startX;
                const deltaY = e.clientY - scrollContainer.getBoundingClientRect().top - startY;
                scrollContainer.scrollLeft = scrollLeft - deltaX;
                scrollContainer.scrollTop = scrollTop - deltaY;
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }
    </script>

</body>

<script src="js/paramname.js"></script>
<script src="js/fileutils.js"></script>
<script src="js/consoleprohibit.js"></script>
<script src="js/userprevent.js"></script>
<script src="js/limitlibs.js"></script>

</html>